(_=>{
    class Canvas {
        /**
         * @param width
         * Width of canvas in pixels. Defaults to window width.
         * @param height
         * Height of canvas in pixels. Defaults to window height.
         * @param parent
         * If parent is an HTML element,(like div or body),the created HTMLCanvasElement will be appended to it.
         * @param transparent
         * If true (default),the created canvas will be able to draw transparent/translucent colors or images.
         */
        constructor(width, height, parent, transparent = true) {
            this.canvas = document.createElement('canvas');
            this.w = this.canvas.width = width || window.innerWidth;
            this.h = this.canvas.height = height || window.innerHeight;
            if (parent && parent.appendChild)
                parent.appendChild(this.canvas);
            this.ctx = this.canvas.getContext('2d', {
                alpha: transparent
            }) || (_ => { throw Error("Unable to create canvas rendering context"); })();
            this.ctx.textAlign = "center";
            this.parent = parent;
            this.textOptions = {
                "font-style": "normal",
                "font-variant": "normal",
                "font-weight": "normal",
                "font-size": "12em",
                "line-height": "1",
                "font-family": "system-ui"
            };
        }
        set width(width) {
            this.resize(width, this.h);
        }
        get width() {
            return this.w;
        }
        set height(height) {
            this.resize(this.w, height);
        }
        get height() {
            return this.h;
        }
        /**
         * Resizes the canvas to the provided dimensions,or the size provided by the CSS attributes.
         * @param width
         * Width in pixels. If not truthy,will be the window width.
         * @param height
         * Height in pixels. If not truthy,will be the window height.
         */
        resize(width, height) {
            this.canvas.width = this.w = width || this.canvas.clientWidth;
            this.canvas.height = this.h = height || this.canvas.clientHeight;
        }
        /**
         * Resizes the canvas to the dimensions of the parent element (Will probably throw error if the parent provided in the constructor was not a HTMLElement)
         */
        resizeToParent() {
            if (!this.parent)
                return;
            this.resize(this.parent.clientWidth, this.parent.clientHeight);
        }
        /**
         * resizes the canvas to the dimensions of the window
         */
        resizeToWindow() {
            this.resize(window.innerWidth, window.innerHeight);
        }
        /**
         * Sets the stroke and fill color of subsequent operations
         * @param color
         * Hex value of the color (like #d4c00b)
         */
        setDrawColor(color) {
            this.ctx.strokeStyle = this.ctx.fillStyle = color;
        }
        /**
         * Sets the stroke color of subsequent operations
         * @param color
         * Hex value of the color (like #d4c00b)
         */
        setStrokeColor(color) {
            this.ctx.strokeStyle = color;
        }
        /**
         * Sets the fill color of subsequent operations
         * @param {string} color
         * Hex value of the color (like #d4c00b)
         */
        setFillColor(color) {
            this.ctx.fillStyle = color;
        }
        /**
         * Sets the stroke width of subsequent operations
         * @param {number} width
         * Stroke width in pixels
         */
        setStrokeWidth(width) {
            this.ctx.lineWidth = width;
        }
        /**
         * Wrapper for ctx.beginPath.
         */
        beginPath() {
            this.ctx.beginPath();
        }
        /**
         * Wrapper for ctx.moveTo.
         * Moves to (x,y). This starts a new line/fill
         */
        moveTo(x, y) {
            this.ctx.moveTo(x, y);
        }
        /**
         * Wrapper for ctx.lineTo
         * Makes a line to (x,y)
         */
        lineTo(x, y) {
            this.ctx.lineTo(x, y);
        }
        /**
         * Wrapper for ctx.arc
         * Draws an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
         * r. If counterclockwise=true,the arc will be inverted (not mirrored)
         */
        arc(x, y, r, a1, a2, counterclockwise = false) {
            this.ctx.arc(x, y, r, a1 * 2 * Math.PI, a2 * 2 * Math.PI, counterclockwise);
        }
        /**
         * Wrapper for ctx.stroke
         * Draws the path onto the canvas
         */
        stroke() {
            this.ctx.stroke();
        }
        /**
         * Wrapper for ctx.fill
         * Fills in the area outlined in the path
         */
        fill() {
            this.ctx.fill();
        }
        /**
         * Wrapper for ctx.closePath
         */
        closePath() {
            this.ctx.closePath();
        }
        /**
         * Clears canvas. If color is provided,fill canvas with color
         * @param color
         * Hex value of the color (like #d4c00b). If not provided,the resulting canvas is transparent if transparency is enabled or white otherwise.
         */
        clear(color) {
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            if (color)
                this.setFillColor(color), this.ctx.fillRect(0, 0, this.w, this.h);
            else
                this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            this.ctx.restore();
        }
        /**
         * Draws a line from x1 to y1.
         */
        line(x1, y1, x2, y2) {
            this.ctx.beginPath();
            this.ctx.moveTo(x1, y1);
            this.ctx.lineTo(x2, y2);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills a rectancle with color. (x1,y1) is the top left corner and (x2,y2) is the bottom right corner.
         */
        fillRect(x1, y1, x2, y2) {
            this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
        }
        /**
         * Draws a rectancle. (x1,y1) is the top left corner and (x2,y2) is the bottom right corner.
         */
        drawRect(x1, y1, x2, y2) {
            this.ctx.beginPath();
            this.ctx.rect(x1, y1, x2 - x1, y2 - y1);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills a square with top left corner at (x1,y1) and width
         */
        fillSquare(x, y, width) {
            this.ctx.fillRect(x, y, width, width);
        }
        /**
         * Draws a square with top left corner at (x,y) and width
         */
        square(x, y, width) {
            this.ctx.beginPath();
            this.ctx.rect(x, y, width, width);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills a circle with center (x,y) and radius r
         */
        fillCircle(x, y, r) {
            this.ctx.beginPath();
            this.ctx.arc(x, y, r, 0, 2 * Math.PI);
            this.ctx.fill();
            this.ctx.closePath();
        }
        /**
         * Draws a circle with center (x,y) and radius r
         */
        circle(x, y, r) {
            this.ctx.beginPath();
            this.ctx.arc(x, y, r - this.ctx.lineWidth / 2, 0, 2 * Math.PI);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
         * r. If counterclockwise=true,the arc will be inverted (not mirrored)
         */
        fillArc(x, y, r, a1, a2, counterclockwise = false) {
            this.beginPath();
            this.moveTo(x, y);
            this.arc(x, y, r, a1, a2);
            this.fill();
            this.closePath();
        }
        /**
         * Draws an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
         * r. If counterclockwise=true,the arc will be inverted (not mirrored)
         */
        drawArc(x, y, r, a1, a2, counterclockwise = false) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, y);
            this.ctx.arc(x, y, r, a1 * 2 * Math.PI, a2 * 2 * Math.PI, counterclockwise);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills an double arc centered at (x,y) from a1 to a2 full turns clockwise with radii
         * r1 and r2. If counterclockwise=true,the arc will be inverted (not mirrored)
         */
        fillDoubleArc(x, y, r1, r2, a1, a2, counterclockwise = false) {
            this.ctx.beginPath();
            this.ctx.arc(x, y, r1, a1 * 2 * Math.PI, a2 * 2 * Math.PI);
            this.ctx.arc(x, y, r2, a2 * 2 * Math.PI, a1 * 2 * Math.PI, counterclockwise);
            this.ctx.fill();
            this.ctx.closePath();
        }
        /**
         * Sets font style
         */
        setFont(family, italic, bold, line_height, small_caps) {
            if (family)
                this.textOptions["font-family"] = family;
            if (italic != undefined)
                this.textOptions["font-style"] = italic ? "italic" : "normal";
            if (bold != undefined)
                this.textOptions["font-weight"] = bold ? "bold" : "normal";
            if (line_height != undefined)
                this.textOptions["line-height"] = line_height.toString();
            if (small_caps != undefined)
                this.textOptions["font-variant"] = small_caps ? "small_caps" : "normal";
        }
        /**
         * Fill text with top left corner at (x,y)
         * @param txt
         * The text to display
         * @param size
         * The font size in pixels
         * @param  font
         * A string parsed like a CSS font property (like "italic bold 16px Times";)
         */
        fillText(txt, x, y, size) {
            this.ctx.beginPath();
            this.ctx.font = [this.textOptions["font-variant"], this.textOptions["font-weight"], size + "px", this.textOptions["font-family"]].join(" ");
            this.ctx.textAlign = "center";
            this.ctx.fillText(txt, x, y);
            this.ctx.closePath();
        }
        /**
         * Outline text with top left corner at (x,y)
         * @param txt
         * The text to display
         * @param size
         * The font size in pixels
         * @param font
         * A string parsed like a CSS font property (like "italic bold 16px Times";)
         */
        strokeText(txt, x, y, size) {
            this.ctx.beginPath();
            this.ctx.font = [this.textOptions["font-variant"], this.textOptions["font-weight"], size + "px", this.textOptions["font-family"]].join(" ");
            this.ctx.textAlign = "center";
            this.ctx.strokeText(txt, x, y);
            this.ctx.closePath();
        }
        /**
         * draws a polygon centered at center
         * @param center
         * center of polygon
         * @param points
         * verticies of polygon
         */
        polygon(center, points) {
            this.ctx.beginPath();
            this.ctx.moveTo(points[points.length - 1][0] + center[0], points[points.length - 1][1] + center[1]);
            let t = this;
            points.forEach(s => t.ctx.lineTo(s[0] + center[0], s[1] + center[1]));
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * fills a polygon centered at center
         * @param center
         * center of polygon
         * @param points
         * verticies of polygon
         */
        fillPolygon(center, points) {
            this.ctx.beginPath();
            this.ctx.moveTo(points[points.length - 1][0] + center[0], points[points.length - 1][1] + center[1]);
            let t = this;
            points.forEach(s => t.ctx.lineTo(s[0] + center[0], s[1] + center[1]));
            this.ctx.fill();
            this.ctx.closePath();
        }
        /**
         * Draws a squircle
         * @param x
         * x-coordinate of the squircle center
         * @param y
         * y-coordinate of the squircle center
         * @param width
         * width of squircle
         * @param r
         * radius of rounded corners
         */
        squircle(x, y, width, r = 5) {
            this.ctx.beginPath();
            this.ctx.arc(x + width / 2 - r, y - width / 2 + r, r, 3 * Math.PI / 2, 0 * Math.PI / 2);
            this.ctx.arc(x + width / 2 - r, y + width / 2 - r, r, 0 * Math.PI / 2, 1 * Math.PI / 2);
            this.ctx.arc(x - width / 2 + r, y + width / 2 - r, r, 1 * Math.PI / 2, 2 * Math.PI / 2);
            this.ctx.arc(x - width / 2 + r, y - width / 2 + r, r, 2 * Math.PI / 2, 3 * Math.PI / 2);
            this.ctx.lineTo(x + width / 2 - r, y - width / 2);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Fills a squircle
         * @param x
         * x-coordinate of the squircle center
         * @param y
         * y-coordinate of the squircle center
         * @param width
         * width of squircle
         * @param r
         * radius of rounded corners
         */
        fillSquircle(x, y, width, r = 5) {
            this.ctx.beginPath();
            this.ctx.arc(x + width / 2 - r, y - width / 2 + r, r, 3 * Math.PI / 2, 0 * Math.PI / 2);
            this.ctx.arc(x + width / 2 - r, y + width / 2 - r, r, 0 * Math.PI / 2, 1 * Math.PI / 2);
            this.ctx.arc(x - width / 2 + r, y + width / 2 - r, r, 1 * Math.PI / 2, 2 * Math.PI / 2);
            this.ctx.arc(x - width / 2 + r, y - width / 2 + r, r, 2 * Math.PI / 2, 3 * Math.PI / 2);
            this.ctx.lineTo(x + width / 2 - r, y - width / 2);
            this.ctx.fill();
            this.ctx.closePath();
        }
        /**
         * Draws a curve through 2 or more points
         * @param points
         * points to draw the curve through
         */
        spline(points) {
            const f = 0.3, t = 0.6;
            this.ctx.beginPath();
            this.ctx.moveTo(points[0][0], points[0][1]);
            let m = 0, dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0;
            let preP = points[0], curP, nexP;
            for (let i = 1; i < points.length; i++) {
                curP = points[i];
                nexP = points[i + 1];
                if (nexP) {
                    m = (preP[1] - curP[1]) / (preP[0] - curP[0]);
                    dx2 = -(nexP[0] - curP[0]) * f;
                    dy2 = dx2 * m * t;
                }
                this.ctx.bezierCurveTo(preP[0] - dx1, preP[1] - dy1, curP[0] + dx2, curP[1] + dy2, curP[0], curP[1]);
                dx1 = dx2;
                dy1 = dy2;
                preP = curP;
            }
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Draws a bezier curve with 3 control points
         * @param p1
         * first control point
         * @param p2
         * second control point
         * @param p3
         * third control point
         */
        bezier(p1, p2, p3) {
            this.ctx.beginPath();
            this.ctx.moveTo(...p1);
            this.ctx.quadraticCurveTo(...p2, ...p3);
            this.ctx.stroke();
            this.ctx.closePath();
        }
        /**
         * Draws unscaled image with top left corner at (x,y)
         */
        drawImage(img, x, y) {
            if (img.width * img.height == 0) {
                console.log(img);
            }
            this.ctx.drawImage(img, x, y);
        }
        /**
         * Draws an image scaled by a factor with top left corner at (x,y)
         */
        drawScaledImage(img, x, y, factor = 1) {
            this.ctx.drawImage(img, x, y, factor * img.width, factor * img.height);
        }
        /**
         * Draws an image scaled to width (preserving the aspect ratio) with top left corner at (x,y)
         */
        drawImageWithWidth(img, x, y, destwidth) {
            let destheight = destwidth / img.width * img.height;
            this.ctx.drawImage(img, x, y, destwidth, destheight);
        }
        /**
         * Draws an image scaled to height (preserving the aspect ratio) with top left corner at (x,y)
         */
        drawImageWithHeight(img, x, y, destheight) {
            let destwidth = destheight / img.height * img.width;
            this.ctx.drawImage(img, x, y, destwidth, destheight);
        }
        /**
         * Draws an image on a rect with top left corner (x1,y1) and bottom right corner (x2,y2)
         */
        drawImageOnRect(img, x1, y1, x2, y2) {
            let destwidth = ~~(x2 - x1);
            let destheight = ~~(y2 - y1);
            this.ctx.drawImage(img, x1, y1, destwidth, destheight);
        }
        /**
         * Wrapper for CanvasRenderingContext2D.save()
         * Saves the current state to a stack
         */
        pushState() {
            this.ctx.save();
        }
        /**
         * Wrapper for CanvasRenderingContext2D.restore()
         * Restores the last state on the stack and pops it from the stack
         */
        restoreState() {
            this.ctx.restore();
        }
        /**
         * rotate context by angle around (x,y) or (0,0) if not present
         * @param angle
         * angle in radians
         * @param clockwise
         * whether to rotate clockwise
         */
        rotate(angle, clockwise = true, x = 0, y = 0) {
            this.ctx.translate(-x, -y);
            this.ctx.rotate(clockwise ? angle : -angle);
            this.ctx.translate(x, y);
        }
        /**
         * translates context x units left and y units down
         */
        translate(x, y) {
            this.ctx.translate(x, y);
        }
        /**
         * Calls f(current time,elapsed time in milliseconds) 60 times per second (or tries to...)
         * @param {Function} f-the function to be called
         */
        static createAnimation(f) {
            let then = 0;
            const f2 = (t) => {
                if (f(0.001 * t, 0.001 * (then - t)))
                    return;
                then = t;
                requestAnimationFrame(f2);
            };
            requestAnimationFrame(f2);
        }
    }
    const SQRT_3_2 = 0.86602540378;
    class Edge {
        constructor(x1, y1, x2, y2, ex, ey) {
            this.x1 = x1;
            this.x2 = x2;
            this.y1 = y1;
            this.y2 = y2;
            this.ex = ex;
            this.ey = ey;
        }
    }
    var STATES;
    (function (STATES) {
        STATES[STATES["IDLE"] = 0] = "IDLE";
        STATES[STATES["DRAWING"] = 1] = "DRAWING";
        STATES[STATES["ERASING"] = 2] = "ERASING";
        STATES[STATES["DRAW_BLENDED_EDGE"] = 3] = "DRAW_BLENDED_EDGE";
    })(STATES || (STATES = {}));
    ;
    class GameDisplay {
        constructor() {
            this.currState = STATES.IDLE;
            this.SIZE = 64;
            this.scale = 33.3;
            this.COLORS = [
                "rgb( 30, 30, 30)",
                "rgb(130,130,130)",
                "rgb(230,230,230)",
                "rgb( 25, 60,100)",
                "rgb(100,130,170)",
                "rgb( 90,  0,  0)",
                "rgb(222,127,127)",
                "rgb(175,227,141)",
                "rgb( 66,135, 33)",
            ];
            this.currColor = 0;
            this.lastMouseX = -1;
            this.lastMouseY = -1;
            this.mouseX = 0;
            this.mouseY = 0;
            this.triangleData = this.edgeData = null;
            this.reset();
            this.canvas = new Canvas(0, 0, document.body);
            window.addEventListener("mousedown", (e) => this.onMouseDown(e.clientX, e.clientY, e.button, e.ctrlKey));
            window.addEventListener("mouseup", (e) => this.onMouseUp(e.clientX, e.clientY));
            window.addEventListener("mousemove", (e) => this.onMouseMove(e.clientX, e.clientY, e.ctrlKey));
            window.addEventListener("wheel", (e) => this.onMouseWheel(e.deltaY));

            window.oncontextmenu = e=>e.preventDefault();

            window.addEventListener("keypress", (e) => this.onKeyPressed(e.which));
            window.onresize = _ => this.canvas.resizeToWindow();
            Canvas.createAnimation((...args) => this.paint(...args));

            this.showGrid = true;
        }
        reset(){
            this.triangleData = new Array(this.SIZE).fill([]).map(i => new Array(this.SIZE * 2).fill(0));
            this.edgeData = new Array(this.SIZE).fill([]).map(i => new Array(this.SIZE * 3).fill(0));
        }

        paint(currTime, elapsedTime) {
            const { COLORS, SIZE, showGrid, scale, canvas, edgeData, triangleData, mouseX, mouseY, currState, currColor} = this;
            this.canvas.clear();
            this.canvas.setStrokeWidth(1);
            const blinking = ((~~(currTime * 15)) & 3) != 0 && this.showGrid;
            if (showGrid) {
                canvas.setStrokeColor("rgb(200,200,200)");
                for (let i = 0; i <= SIZE; i++) {
                    canvas.line(~~(i * scale * SQRT_3_2), 0, ~~(i * scale * SQRT_3_2), ~~(SIZE * scale));
                }
                for (let i = 0; i <= SIZE * 3 / 2; i++) {
                    canvas.line(0, ~~(i * scale), ~~(SIZE * scale * SQRT_3_2), ~~((i - SIZE / 2) * scale));
                    canvas.line(0, ~~((i - SIZE / 2) * scale), ~~(SIZE * scale * SQRT_3_2), ~~(i * scale));
                }
                canvas.setFillColor("#FFF");
                canvas.fillRect(0, ~~(SIZE * scale), ~~(SIZE * scale * SQRT_3_2), ~~(SIZE / 2 * scale));
                for (let i = 0; i < SIZE; i += 2)
                    canvas.fillPolygon([0, 0], [
                        [~~((i) * scale * SQRT_3_2) + 1, ~~((SIZE - 1) * scale) + 1],
                        [~~((i) * scale * SQRT_3_2) + 1, ~~(SIZE * scale) + 1],
                        [~~((i + 2) * scale * SQRT_3_2) - 1, ~~(SIZE * scale) + 1],
                    ]);
            }
            //Draw filled triangles (or triangle outlines)
            for (let i = 0; i < SIZE; i++) {
                let x1 = ~~((i - 1.) * scale), x2 = ~~((i - .5) * scale), x3 = ~~((i + 0.) * scale), x4 = ~~((i + .5) * scale), x5 = ~~((i + 1.) * scale);
                for (let j = 0; j < SIZE * 2; j++) {
                    let y1 = ~~((j >> 1) * scale * SQRT_3_2), y2 = ~~(((j >> 1) + 1) * scale * SQRT_3_2);
                    if (i == mouseX && j == mouseY && blinking) { //cell is hovered over
                        if (blinking && currState != STATES.ERASING) {
                            canvas.setDrawColor(COLORS[currColor]);
                            this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        }
                    }
                    else if (triangleData[i][j] > 0) { //cell has color
                        canvas.setDrawColor(COLORS[triangleData[i][j] - 1]);
                        this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        // this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        // this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        // this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        // this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                        // this.fillTriAt(x1, x2, x3, x4, x5, y1, y2, j);
                    }
                }
            }
            //Draw edges
            canvas.setStrokeColor("#000");
            for (let i = 0; i < SIZE; i++) {
                let x1 = ~~((i - 1.) * scale), x2 = ~~((i - .5) * scale), x3 = ~~((i + 0.) * scale), x4 = ~~((i + .5) * scale);
                for (let j = 0; j < SIZE * 3; j++) {
                    let y1 = ~~(~~(j / 3) * scale * SQRT_3_2), y2 = ~~((~~(j / 3) + 1) * scale * SQRT_3_2);
                    if (edgeData[i][j]) this.drawEdge(x1, x2, x3, x4, y1, y2, j);
                }
            }
        }
        getTriCoords(x1, x2, x3, x4, x5, y1, y2, j){
            switch (j & 3) {
                case 0: return [[y1, x1], [y2, x2], [y1, x3]];
                case 1: return [[y2, x2], [y1, x3], [y2, x4]];
                case 2: return [[y1, x2], [y2, x3], [y1, x4]];
                case 3: return [[y2, x3], [y1, x4], [y2, x5]]
                default:return []
            }
        }
        fillTriAt(x1, x2, x3, x4, x5, y1, y2, j) {
            const triCoords = this.getTriCoords(x1, x2, x3, x4, x5, y1, y2, j);
            this.canvas.fillPolygon([0, 0], triCoords);
            this.canvas.polygon([0, 0], triCoords);
        }
        getAdjacentEdges(x, y) {
            let y_ = (y >> 2) * 6;
            switch (y & 3) {
                case 0:
                    return [
                        new Edge(x, y, x - 1, y + 1, x + 0, y_ + 1),
                        new Edge(x, y, x - 1, y - 1, x + 0, y_ + 0),
                        new Edge(x, y, x + 0, y + 1, x + 0, y_ + 2),
                    ];
                case 1:
                    return [
                        new Edge(x, y, x + 0, y + 1, x + 0, y_ + 3),
                        new Edge(x, y, x + 0, y - 1, x + 0, y_ + 2),
                        new Edge(x, y, x + 1, y - 1, x + 1, y_ + 1),
                    ];
                case 2:
                    return [
                        new Edge(x, y, x + 0, y - 1, x + 0, y_ + 3),
                        new Edge(x, y, x - 1, y + 1, x + 0, y_ + 4),
                        new Edge(x, y, x + 0, y + 1, x + 0, y_ + 5),
                    ];
                case 3:
                    return [
                        new Edge(x, y, x + 1, y - 1, x + 1, y_ + 4),
                        new Edge(x, y, x + 0, y - 1, x + 0, y_ + 5),
                        new Edge(x, y, x + 1, y + 1, x + 1, y_ + 6),
                    ];
                default: return [];
            }
        }
        drawEdge(x1, x2, x3, x4, y1, y2, j) {
            switch (j % 6) {
                case 0:
                    this.canvas.line(y1, x1, y1, x3);
                    break;
                case 1:
                    this.canvas.line(y1, x1, y2, x2);
                    break;
                case 2:
                    this.canvas.line(y2, x2, y1, x3);
                    break;
                case 3:
                    this.canvas.line(y1, x2, y1, x4);
                    break;
                case 4:
                    this.canvas.line(y1, x2, y2, x3);
                    break;
                case 5:
                    this.canvas.line(y2, x3, y1, x4);
                    break;
                default: break;
            }
        }
        drawBlendedEdge() {
            const { mouseX, mouseY, currColor } = this;
            this.triangleData[mouseX][mouseY] = currColor + 1;
            for (let e of this.getAdjacentEdges(mouseX, mouseY)) {
                this.edgeData[e.ex][e.ey] = this.triangleData[e.x2][e.y2] != currColor + 1;
            }
        }
        drawNormal() {
            const { lastMouseX, lastMouseY, mouseX, mouseY, currColor } = this;
            this.triangleData[mouseX][mouseY] = currColor + 1;
            if (mouseX != lastMouseX || mouseY != lastMouseY) {
                for (let e of this.getAdjacentEdges(mouseX, mouseY)) {
                    this.edgeData[e.ex][e.ey] = e.x2 != lastMouseX || e.y2 != lastMouseY;
                }
            }
        }
        erase() {
            const { mouseX, mouseY, currColor } = this;
            this.triangleData[mouseX][mouseY] = 0;
            for (let e of this.getAdjacentEdges(mouseX, mouseY)) {
                this.edgeData[e.ex][e.ey] = this.triangleData[e.x1][e.y1] + this.triangleData[e.x2][e.y2] != 0;
            }
        }
        onKeyPressed(keyCode) {
            console.log(keyCode);
            switch (keyCode) {
                case 187:
                    this.scale *= 1.01;
                    break;
                case 189:
                    this.scale *= 0.99;
                    break;
                case 49:
                case 50:
                case 51:
                case 52:
                case 53:
                case 54:
                case 55:
                case 56:
                case 57:
                    this.currColor = keyCode - 49;
                    break;
                case 114:
                    this.reset();
                    break;
                case 118:
                    this.showGrid = !this.showGrid;
                    break;
                default: break;
            }
        }
        onMouseDown(x, y, b, ctrlKey) {
            switch (b) {
                case 0:
                    this.currState = STATES.DRAW_BLENDED_EDGE;
                    this.onMouseMove(x, y, ctrlKey);
                    break;
                case 1: break;
                case 2:
                    this.currState = STATES.ERASING;
                    this.onMouseMove(x, y, ctrlKey);
                    break;
            }
        }
        onMouseUp(x, y) {
            this.currState = STATES.IDLE;
            this.lastMouseX = this.lastMouseY = -1;
        }
        onMouseMove(x, y, ctrlKey) {
            this.lastMouseX = this.mouseX;
            this.lastMouseY = this.mouseY;
            let Y = x / this.scale / SQRT_3_2, X = y / this.scale - 0.5 * (Y % 2) + 1;
            this.mouseX = ~~X;
            this.mouseY = 2 * ~~Y + ((X % 1) + (Y % 1) >= 1 ? 1 : 0);
            switch (this.currState) {
                case STATES.IDLE: break;
                case STATES.DRAW_BLENDED_EDGE:
                    this.drawBlendedEdge();
                    if (!ctrlKey)
                        this.currState = STATES.DRAWING;
                    break;
                case STATES.DRAWING:
                    this.drawNormal();
                    if (ctrlKey)
                        this.currState = STATES.DRAW_BLENDED_EDGE;
                    break;
                case STATES.ERASING:
                    this.erase();
                    break;
            }
        }
        onMouseWheel(d) {
            this.scale *= 1 - d * .0004;
        }
    }
window.a = new GameDisplay();

})();