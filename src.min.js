(_=>{

class Canvas {
    /**
     * @param width
     * Width of canvas in pixels. Defaults to window width.
     * @param height
     * Height of canvas in pixels. Defaults to window height.
     * @param parent
     * If parent is an HTML element,(like div or body),the created HTMLCanvasElement will be appended to it.
     * @param transparent
     * If true (default),the created canvas will be able to draw transparent/translucent colors or images.
     */
    constructor(width, height, parent, transparent = true) {
        this.canvas = document.createElement('canvas');
        this.w = this.canvas.width = width || window.innerWidth;
        this.h = this.canvas.height = height || window.innerHeight;
        if (parent && parent.appendChild)
            parent.appendChild(this.canvas);
        this.ctx = this.canvas.getContext('2d', {
            alpha: transparent
        }) || (_ => { throw Error("Unable to create canvas rendering context"); })();
        this.ctx.textAlign = "center";
        this.parent = parent;
        this.textOptions = {
            "font-style": "normal",
            "font-variant": "normal",
            "font-weight": "normal",
            "font-size": "12em",
            "line-height": "1",
            "font-family": "system-ui"
        };
    }
    set width(width) {
        this.resize(width, this.h);
    }
    get width() {
        return this.w;
    }
    set height(height) {
        this.resize(this.w, height);
    }
    get height() {
        return this.h;
    }
    /**
     * Resizes the canvas to the provided dimensions,or the size provided by the CSS attributes.
     * @param width
     * Width in pixels. If not truthy,will be the window width.
     * @param height
     * Height in pixels. If not truthy,will be the window height.
     */
    resize(width, height) {
        this.canvas.width = this.w = width || this.canvas.clientWidth;
        this.canvas.height = this.h = height || this.canvas.clientHeight;
    }
    /**
     * Resizes the canvas to the dimensions of the parent element (Will probably throw error if the parent provided in the constructor was not a HTMLElement)
     */
    resizeToParent() {
        if (!this.parent)
            return;
        this.resize(this.parent.clientWidth, this.parent.clientHeight);
    }
    /**
     * resizes the canvas to the dimensions of the window
     */
    resizeToWindow() {
        this.resize(window.innerWidth, window.innerHeight);
    }
    /**
     * Sets the stroke and fill color of subsequent operations
     * @param color
     * Hex value of the color (like #d4c00b)
     */
    setDrawColor(color) {
        this.ctx.strokeStyle = this.ctx.fillStyle = color;
    }
    /**
     * Sets the stroke color of subsequent operations
     * @param color
     * Hex value of the color (like #d4c00b)
     */
    setStrokeColor(color) {
        this.ctx.strokeStyle = color;
    }
    /**
     * Sets the fill color of subsequent operations
     * @param {string} color
     * Hex value of the color (like #d4c00b)
     */
    setFillColor(color) {
        this.ctx.fillStyle = color;
    }
    /**
     * Sets the stroke width of subsequent operations
     * @param {number} width
     * Stroke width in pixels
     */
    setStrokeWidth(width) {
        this.ctx.lineWidth = width;
    }
    /**
     * Wrapper for ctx.beginPath.
     */
    beginPath() {
        this.ctx.beginPath();
    }
    /**
     * Wrapper for ctx.moveTo.
     * Moves to (x,y). This starts a new line/fill
     */
    moveTo(x, y) {
        this.ctx.moveTo(x, y);
    }
    /**
     * Wrapper for ctx.lineTo
     * Makes a line to (x,y)
     */
    lineTo(x, y) {
        this.ctx.lineTo(x, y);
    }
    /**
     * Wrapper for ctx.arc
     * Draws an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
     * r. If counterclockwise=true,the arc will be inverted (not mirrored)
     */
    arc(x, y, r, a1, a2, counterclockwise = false) {
        this.ctx.arc(x, y, r, a1 * 2 * Math.PI, a2 * 2 * Math.PI, counterclockwise);
    }
    /**
     * Wrapper for ctx.stroke
     * Draws the path onto the canvas
     */
    stroke() {
        this.ctx.stroke();
    }
    /**
     * Wrapper for ctx.fill
     * Fills in the area outlined in the path
     */
    fill() {
        this.ctx.fill();
    }
    /**
     * Wrapper for ctx.closePath
     */
    closePath() {
        this.ctx.closePath();
    }
    /**
     * Clears canvas. If color is provided,fill canvas with color
     * @param color
     * Hex value of the color (like #d4c00b). If not provided,the resulting canvas is transparent if transparency is enabled or white otherwise.
     */
    clear(color) {
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (color)
            this.setFillColor(color), this.ctx.fillRect(0, 0, this.w, this.h);
        else
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.ctx.restore();
    }
    /**
     * Draws a line from x1 to y1.
     */
    line(x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills a rectancle with color. (x1,y1) is the top left corner and (x2,y2) is the bottom right corner.
     */
    fillRect(x1, y1, x2, y2) {
        this.ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
    }
    /**
     * Draws a rectancle. (x1,y1) is the top left corner and (x2,y2) is the bottom right corner.
     */
    drawRect(x1, y1, x2, y2) {
        this.ctx.beginPath();
        this.ctx.rect(x1, y1, x2 - x1, y2 - y1);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills a square with top left corner at (x1,y1) and width
     */
    fillSquare(x, y, width) {
        this.ctx.fillRect(x, y, width, width);
    }
    /**
     * Draws a square with top left corner at (x,y) and width
     */
    square(x, y, width) {
        this.ctx.beginPath();
        this.ctx.rect(x, y, width, width);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills a circle with center (x,y) and radius r
     */
    fillCircle(x, y, r) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r, 0, 2 * Math.PI);
        this.ctx.fill();
        this.ctx.closePath();
    }
    /**
     * Draws a circle with center (x,y) and radius r
     */
    circle(x, y, r) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r - this.ctx.lineWidth / 2, 0, 2 * Math.PI);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
     * r. If counterclockwise=true,the arc will be inverted (not mirrored)
     */
    fillArc(x, y, r, a1, a2, counterclockwise = false) {
        this.beginPath();
        this.moveTo(x, y);
        this.arc(x, y, r, a1, a2);
        this.fill();
        this.closePath();
    }
    /**
     * Draws an arc centered at (x,y) from a1 to a2 full turns clockwise with radius
     * r. If counterclockwise=true,the arc will be inverted (not mirrored)
     */
    drawArc(x, y, r, a1, a2, counterclockwise = false) {
        this.ctx.beginPath();
        this.ctx.moveTo(x, y);
        this.ctx.arc(x, y, r, a1 * 2 * Math.PI, a2 * 2 * Math.PI, counterclockwise);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills an double arc centered at (x,y) from a1 to a2 full turns clockwise with radii
     * r1 and r2. If counterclockwise=true,the arc will be inverted (not mirrored)
     */
    fillDoubleArc(x, y, r1, r2, a1, a2, counterclockwise = false) {
        this.ctx.beginPath();
        this.ctx.arc(x, y, r1, a1 * 2 * Math.PI, a2 * 2 * Math.PI);
        this.ctx.arc(x, y, r2, a2 * 2 * Math.PI, a1 * 2 * Math.PI, counterclockwise);
        this.ctx.fill();
        this.ctx.closePath();
    }
    /**
     * Sets font style
     */
    setFont(family, italic, bold, line_height, small_caps) {
        if (family)
            this.textOptions["font-family"] = family;
        if (italic != undefined)
            this.textOptions["font-style"] = italic ? "italic" : "normal";
        if (bold != undefined)
            this.textOptions["font-weight"] = bold ? "bold" : "normal";
        if (line_height != undefined)
            this.textOptions["line-height"] = line_height.toString();
        if (small_caps != undefined)
            this.textOptions["font-variant"] = small_caps ? "small_caps" : "normal";
    }
    /**
     * Fill text with top left corner at (x,y)
     * @param txt
     * The text to display
     * @param size
     * The font size in pixels
     * @param  font
     * A string parsed like a CSS font property (like "italic bold 16px Times";)
     */
    fillText(txt, x, y, size) {
        this.ctx.beginPath();
        this.ctx.font = [this.textOptions["font-variant"], this.textOptions["font-weight"], size + "px", this.textOptions["font-family"]].join(" ");
        this.ctx.textAlign = "center";
        this.ctx.fillText(txt, x, y);
        this.ctx.closePath();
    }
    /**
     * Outline text with top left corner at (x,y)
     * @param txt
     * The text to display
     * @param size
     * The font size in pixels
     * @param font
     * A string parsed like a CSS font property (like "italic bold 16px Times";)
     */
    strokeText(txt, x, y, size) {
        this.ctx.beginPath();
        this.ctx.font = [this.textOptions["font-variant"], this.textOptions["font-weight"], size + "px", this.textOptions["font-family"]].join(" ");
        this.ctx.textAlign = "center";
        this.ctx.strokeText(txt, x, y);
        this.ctx.closePath();
    }
    /**
     * draws a polygon centered at center
     * @param center
     * center of polygon
     * @param points
     * verticies of polygon
     */
    polygon(center, points) {
        this.ctx.beginPath();
        this.ctx.moveTo(points[points.length - 1][0] + center[0], points[points.length - 1][1] + center[1]);
        let t = this;
        points.forEach(s => t.ctx.lineTo(s[0] + center[0], s[1] + center[1]));
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * fills a polygon centered at center
     * @param center
     * center of polygon
     * @param points
     * verticies of polygon
     */
    fillPolygon(center, points) {
        this.ctx.beginPath();
        this.ctx.moveTo(points[points.length - 1][0] + center[0], points[points.length - 1][1] + center[1]);
        let t = this;
        points.forEach(s => t.ctx.lineTo(s[0] + center[0], s[1] + center[1]));
        this.ctx.fill();
        this.ctx.closePath();
    }
    /**
     * Draws a squircle
     * @param x
     * x-coordinate of the squircle center
     * @param y
     * y-coordinate of the squircle center
     * @param width
     * width of squircle
     * @param r
     * radius of rounded corners
     */
    squircle(x, y, width, r = 5) {
        this.ctx.beginPath();
        this.ctx.arc(x + width / 2 - r, y - width / 2 + r, r, 3 * Math.PI / 2, 0 * Math.PI / 2);
        this.ctx.arc(x + width / 2 - r, y + width / 2 - r, r, 0 * Math.PI / 2, 1 * Math.PI / 2);
        this.ctx.arc(x - width / 2 + r, y + width / 2 - r, r, 1 * Math.PI / 2, 2 * Math.PI / 2);
        this.ctx.arc(x - width / 2 + r, y - width / 2 + r, r, 2 * Math.PI / 2, 3 * Math.PI / 2);
        this.ctx.lineTo(x + width / 2 - r, y - width / 2);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Fills a squircle
     * @param x
     * x-coordinate of the squircle center
     * @param y
     * y-coordinate of the squircle center
     * @param width
     * width of squircle
     * @param r
     * radius of rounded corners
     */
    fillSquircle(x, y, width, r = 5) {
        this.ctx.beginPath();
        this.ctx.arc(x + width / 2 - r, y - width / 2 + r, r, 3 * Math.PI / 2, 0 * Math.PI / 2);
        this.ctx.arc(x + width / 2 - r, y + width / 2 - r, r, 0 * Math.PI / 2, 1 * Math.PI / 2);
        this.ctx.arc(x - width / 2 + r, y + width / 2 - r, r, 1 * Math.PI / 2, 2 * Math.PI / 2);
        this.ctx.arc(x - width / 2 + r, y - width / 2 + r, r, 2 * Math.PI / 2, 3 * Math.PI / 2);
        this.ctx.lineTo(x + width / 2 - r, y - width / 2);
        this.ctx.fill();
        this.ctx.closePath();
    }
    /**
     * Draws a curve through 2 or more points
     * @param points
     * points to draw the curve through
     */
    spline(points) {
        const f = 0.3, t = 0.6;
        this.ctx.beginPath();
        this.ctx.moveTo(points[0][0], points[0][1]);
        let m = 0, dx1 = 0, dy1 = 0, dx2 = 0, dy2 = 0;
        let preP = points[0], curP, nexP;
        for (let i = 1; i < points.length; i++) {
            curP = points[i];
            nexP = points[i + 1];
            if (nexP) {
                m = (preP[1] - curP[1]) / (preP[0] - curP[0]);
                dx2 = -(nexP[0] - curP[0]) * f;
                dy2 = dx2 * m * t;
            }
            this.ctx.bezierCurveTo(preP[0] - dx1, preP[1] - dy1, curP[0] + dx2, curP[1] + dy2, curP[0], curP[1]);
            dx1 = dx2;
            dy1 = dy2;
            preP = curP;
        }
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Draws a bezier curve with 3 control points
     * @param p1
     * first control point
     * @param p2
     * second control point
     * @param p3
     * third control point
     */
    bezier(p1, p2, p3) {
        this.ctx.beginPath();
        this.ctx.moveTo(...p1);
        this.ctx.quadraticCurveTo(...p2, ...p3);
        this.ctx.stroke();
        this.ctx.closePath();
    }
    /**
     * Draws unscaled image with top left corner at (x,y)
     */
    drawImage(img, x, y) {
        if (img.width * img.height == 0) {
            console.log(img);
        }
        this.ctx.drawImage(img, x, y);
    }
    /**
     * Draws an image scaled by a factor with top left corner at (x,y)
     */
    drawScaledImage(img, x, y, factor = 1) {
        this.ctx.drawImage(img, x, y, factor * img.width, factor * img.height);
    }
    /**
     * Draws an image scaled to width (preserving the aspect ratio) with top left corner at (x,y)
     */
    drawImageWithWidth(img, x, y, destwidth) {
        let destheight = destwidth / img.width * img.height;
        this.ctx.drawImage(img, x, y, destwidth, destheight);
    }
    /**
     * Draws an image scaled to height (preserving the aspect ratio) with top left corner at (x,y)
     */
    drawImageWithHeight(img, x, y, destheight) {
        let destwidth = destheight / img.height * img.width;
        this.ctx.drawImage(img, x, y, destwidth, destheight);
    }
    /**
     * Draws an image on a rect with top left corner (x1,y1) and bottom right corner (x2,y2)
     */
    drawImageOnRect(img, x1, y1, x2, y2) {
        let destwidth = ~~(x2 - x1);
        let destheight = ~~(y2 - y1);
        this.ctx.drawImage(img, x1, y1, destwidth, destheight);
    }
    /**
     * Wrapper for CanvasRenderingContext2D.save()
     * Saves the current state to a stack
     */
    pushState() {
        this.ctx.save();
    }
    /**
     * Wrapper for CanvasRenderingContext2D.restore()
     * Restores the last state on the stack and pops it from the stack
     */
    restoreState() {
        this.ctx.restore();
    }
    /**
     * rotate context by angle around (x,y) or (0,0) if not present
     * @param angle
     * angle in radians
     * @param clockwise
     * whether to rotate clockwise
     */
    rotate(angle, clockwise = true, x = 0, y = 0) {
        this.ctx.translate(-x, -y);
        this.ctx.rotate(clockwise ? angle : -angle);
        this.ctx.translate(x, y);
    }
    /**
     * translates context x units left and y units down
     */
    translate(x, y) {
        this.ctx.translate(x, y);
    }
    /**
     * Calls f(current time,elapsed time in milliseconds) 60 times per second (or tries to...)
     * @param {Function} f-the function to be called
     */
    static createAnimation(f) {
        let then = 0;
        const f2 = (t) => {
            if (f(0.001 * t, 0.001 * (then - t)))
                return;
            then = t;
            requestAnimationFrame(f2);
        };
        requestAnimationFrame(f2);
    }
}
const SQRT_3_2 = 0.86602540378;
var STATES;
(function (STATES) {
    STATES[STATES["IDLE"] = 0] = "IDLE";
    STATES[STATES["DRAWING"] = 1] = "DRAWING";
    STATES[STATES["ERASING"] = 2] = "ERASING";
    STATES[STATES["DRAW_BLENDED_EDGE"] = 3] = "DRAW_BLENDED_EDGE";
})(STATES || (STATES = {}));
;
class GameDisplay {
    constructor() {
        this.currState = STATES.IDLE;
        this.SIZE = 64;
        this.scale = 33.3;
        this.COLORS = [
            "rgb( 30, 30, 30)",
            "rgb(130,130,130)",
            "rgb(230,230,230)",
            "rgb( 25, 60,100)",
            "rgb(100,130,170)",
            "rgb( 90,  0,  0)",
            "rgb(222,127,127)",
            "rgb(175,227,141)",
            "rgb( 66,135, 33)",
        ];
        this.showGrid = true;
        this.canvas = new Canvas(0, 0, document.body);
        this.canvas.canvas.addEventListener("mousedown", (e) => this.onMouseDown(e.clientX, e.clientY));
        this.canvas.canvas.addEventListener("mouseup", (e) => this.onMouseUp(e.clientX, e.clientY));
        this.canvas.canvas.addEventListener("mousemove", (e) => this.onMouseDown(e.clientX, e.clientY));
        this.canvas.canvas.addEventListener("wheel", (e) => this.onMouseWheel(e.deltaY));
        window.addEventListener("keypress", (e) => this.onKeyPressed(e.keyCode));
        window.addEventListener("resize", _ => this.canvas.resizeToWindow());
        Canvas.createAnimation((...args) => this.paint(...args));
    }
    paint(currTime, elapsedTime) {

        this.canvas.clear("#FFF");

        const blinking = ((~~(currTime * 15)) & 3) != 0 && this.showGrid;
        if (this.showGrid) {
            this.canvas.setStrokeColor("rgb(200,200,200)");
            for (let i = 0; i <= this.SIZE; i++) {
                this.canvas.line(~~(i * this.scale * SQRT_3_2), 0, ~~(i * this.scale * SQRT_3_2), ~~(this.SIZE * this.scale));
            }
            for (let i = 0; i <= this.SIZE * 3 / 2; i++) {
                this.canvas.line(0, ~~(i * this.scale), ~~(this.SIZE * this.scale * SQRT_3_2), ~~((i - this.SIZE / 2) * this.scale));
                this.canvas.line(0, ~~((i - this.SIZE / 2) * this.scale), ~~(this.SIZE * this.scale * SQRT_3_2), ~~(i * this.scale));
            }
            this.canvas.setFillColor("#FFF");
            this.canvas.fillRect(0, ~~(this.SIZE * this.scale), ~~(this.SIZE * this.scale * SQRT_3_2), ~~(this.SIZE / 2 * this.scale));
            for (let i = 0; i < this.SIZE; i += 2)
                this.canvas.fillPolygon([0, 0], [
                    [~~((i) * this.scale * SQRT_3_2) + 1, ~~((this.SIZE - 1) * this.scale) + 1],
                    [~~((i) * this.scale * SQRT_3_2) + 1, ~~(this.SIZE * this.scale) + 1],
                    [~~((i + 2) * this.scale * SQRT_3_2) - 1, ~~(this.SIZE * this.scale) + 1],
                ]);
        }
        // //Draw filled triangles (or triangle outlines)
        // for(let i = 0; i < this.SIZE; i++){
        //     let x1 = ~~((i - 1.) * scale), x2 = ~~((i - .5) * scale),
        //         x3 = ~~((i + 0.) * scale), x4 = ~~((i + .5) * scale),
        //         x5 = ~~((i + 1.) * scale);
        //     for(let j = 0; j < this.SIZE * 2; j++){
        //         let y1 = ~~((j / 2) * scale * SQRT_3_2), y2 = ~~((j / 2 + 1) * scale * SQRT_3_2);
        //         if(i == mouseX && j == mouseY && blinking){ //cell is hovered over
        //             if(blinking && currState != States.ERASING){
        //                 g.setColor(COLORS[this.currColor]);
        //                 fillTriAt(g,x1,x2,x3,x4,x5,y1,y2,j);
        //             }
        //         }
        //         else if(triangleData[i][j] > 0){   //cell has color
        //             g.setColor(COLORS[triangleData[i][j] - 1]);
        //             fillTriAt(g,x1,x2,x3,x4,x5,y1,y2,j);
        //         }
        //     }
        // }
        // //Draw edges
        // g.setColor(Color.BLACK);
        // for(let i = 0; i < this.SIZE; i++){
        //     let x1 = ~~((i - 1.) * scale), x2 = ~~((i - .5) * scale),
        //         x3 = ~~((i + 0.) * scale), x4 = ~~((i + .5) * scale);
        //     for(let j = 0; j < this.SIZE * 3; j++){
        //         let y1 = ~~((j / 3) * scale * SQRT_3_2), y2 = ~~((j / 3 + 1) * scale * SQRT_3_2);
        //         if(edgeData[i][j]) drawEdge(g,x1,x2,x3,x4,y1,y2,j);
        //     }
        // }
    }
    // private void fillTriAt(Graphics2D g, let x1, let x2, let x3, let x4, let x5, let y1, let y2, let j){
    //     switch(j & 3){
    //         case 0:
    //             g.fillPolygon(new let[]{y1,y2,y1}, new let[]{x1,x2,x3}, 3);
    //             break;
    //         case 1:
    //             g.fillPolygon(new let[]{y2,y1,y2}, new let[]{x2,x3,x4}, 3);
    //             break;
    //         case 2:
    //             g.fillPolygon(new let[]{y1,y2,y1}, new let[]{x2,x3,x4}, 3);
    //             break;
    //         case 3:
    //             g.fillPolygon(new let[]{y2,y1,y2}, new let[]{x3,x4,x5}, 3);
    //             break;
    //         default: break;
    //     }
    // }
    // public static class Edge{
    //     public let x1,y1,x2,y2,ex,ey;
    //     public Edge(let x1,let y1,let x2,let y2,let ex,let ey){
    //         this.x1 = x1; this.x2 = x2;
    //         this.y1 = y1; this.y2 = y2;
    //         this.ex = ex; this.ey = ey;
    //     }
    // }
    // public Edge[] getAdjacentEdges(let x, let y){
    //     let y_ = (y >> 2) * 6;
    //     switch(y & 3){
    //         case 0:
    //             return new Edge[]{
    //                 new Edge(x,y,x - 1, y + 1, x + 0, y_ + 1),
    //                 new Edge(x,y,x - 1, y - 1, x + 0, y_ + 0),
    //                 new Edge(x,y,x + 0, y + 1, x + 0, y_ + 2),
    //             };
    //         case 1:
    //             return new Edge[]{
    //                 new Edge(x,y,x + 0, y + 1, x + 0, y_ + 3),
    //                 new Edge(x,y,x + 0, y - 1, x + 0, y_ + 2),
    //                 new Edge(x,y,x + 1, y - 1, x + 1, y_ + 1),
    //             };
    //         case 2:
    //             return new Edge[]{
    //                 new Edge(x,y,x + 0, y - 1, x + 0, y_ + 3),
    //                 new Edge(x,y,x - 1, y + 1, x + 0, y_ + 4),
    //                 new Edge(x,y,x + 0, y + 1, x + 0, y_ + 5),
    //             };
    //         case 3:
    //             return new Edge[]{
    //                 new Edge(x,y,x + 1, y - 1, x + 1, y_ + 4),
    //                 new Edge(x,y,x + 0, y - 1, x + 0, y_ + 5),
    //                 new Edge(x,y,x + 1, y + 1, x + 1, y_ + 6),
    //             };
    //         default: return new Edge[]{};
    //     }
    // }
    // public void drawEdge(Graphics2D g, let x1, let x2, let x3, let x4, let y1, let y2, let j){
    //     switch(j % 6){
    //         case 0:
    //             g.drawLine(y1,x1,y1,x3);
    //             break;
    //         case 1:
    //             g.drawLine(y1,x1,y2,x2);
    //             break;
    //         case 2:
    //             g.drawLine(y2,x2,y1,x3);
    //             break;
    //         case 3:
    //             g.drawLine(y1,x2,y1,x4);
    //             break;
    //         case 4:
    //             g.drawLine(y1,x2,y2,x3);
    //             break;
    //         case 5:
    //             g.drawLine(y2,x3,y1,x4);
    //             break;
    //         default: break;
    //     }
    // }
    // //#region MouseObserver interface implementations
    // @Override
    // public void onMouseMove(let x, let y) {
    //     lastMouseX = mouseX;
    //     lastMouseY = mouseY;
    //     double Y = x / scale / SQRT_3_2, X = y / scale - 0.5 * (Y % 2) + 1;
    //     mouseX = ~~X;
    //     mouseY = 2 * ~~Y + ((X % 1.0) + (Y % 1.0) >= 1 ? 1 : 0);
    //     switch(currState){
    //         case IDLE: break;
    //         case DRAW_BLENDED_EDGE:
    //             drawBlendedEdge();
    //             if(!keys.isKeyPressed(KeyEvent.VK_CONTROL)) currState = States.DRAWING;
    //             break;
    //         case DRAWING:
    //             drawNormal();
    //             if(keys.isKeyPressed(KeyEvent.VK_CONTROL)) currState = States.DRAW_BLENDED_EDGE;
    //             break;
    //         case ERASING:
    //             erase();
    //             break;
    //     }
    // }
    // //#region drawing functions
    // private void drawBlendedEdge(){
    //     triangleData[mouseX][mouseY] = currColor + 1;
    //     for(Edge e : getAdjacentEdges(mouseX, mouseY)){
    //         edgeData[e.ex][e.ey] = triangleData[e.x2][e.y2] != currColor + 1;
    //     }
    // }
    // private void drawNormal(){
    //     triangleData[mouseX][mouseY] = currColor + 1;
    //     if(mouseX != lastMouseX || mouseY != lastMouseY){
    //         for(Edge e : getAdjacentEdges(mouseX, mouseY)){
    //             edgeData[e.ex][e.ey] = e.x2 != lastMouseX || e.y2 != lastMouseY;
    //         }
    //     }
    // }
    // private void erase(){
    //     triangleData[mouseX][mouseY] = 0;
    //     for(Edge e : getAdjacentEdges(mouseX, mouseY)){
    //         edgeData[e.ex][e.ey] = triangleData[e.x1][e.y1] + triangleData[e.x2][e.y2] != 0;
    //     }
    // }
    // //#endregion
    // @Override
    // public void onMouseWheel(let wheelRotation) {
    //     scale *= 1. - .01 * wheelRotation;
    // }
    // @Override
    // public void onMouseClick(let x, let y, MyMouseListener.Button b) {}
    // @Override
    // public void onMouseDown(let x, let y, MyMouseListener.Button b) {
    //     switch(b){
    //         case LEFT_CLICK:
    //             currState = States.DRAW_BLENDED_EDGE;
    //             onMouseMove(x,y);
    //             break;
    //         case MIDDLE_CLICK: break;
    //         case RIGHT_CLICK:
    //             currState = States.ERASING;
    //             onMouseMove(x,y);
    //             break;
    //         case NO_CLICK: break;
    //     }
    // }
    // @Override
    // public void onMouseUp(let x, let y, MyMouseListener.Button b) {
    //     currState = States.IDLE;
    //     lastMouseX = lastMouseY = -1;
    // }
    // //#endregion
    // //#region KeyObserver interface implementations
    // @Override
    // public void onKeyPressed(let keyCode) {
    //     switch(keyCode){
    //         case KeyEvent.VK_EQUALS:
    //             scale *= 1.01;
    //             break;
    //         case KeyEvent.VK_MINUS:
    //             scale *= 0.99;
    //             break;
    //         case KeyEvent.VK_1:
    //             currColor = 0; break;
    //         case KeyEvent.VK_2:
    //             currColor = 1; break;
    //         case KeyEvent.VK_3:
    //             currColor = 2; break;
    //         case KeyEvent.VK_4:
    //             currColor = 3; break;
    //         case KeyEvent.VK_5:
    //             currColor = 4; break;
    //         case KeyEvent.VK_6:
    //             currColor = 5; break;
    //         case KeyEvent.VK_7:
    //             currColor = 6; break;
    //         case KeyEvent.VK_8:
    //             currColor = 7; break;
    //         case KeyEvent.VK_9:
    //             currColor = 8; break;
    //         case KeyEvent.VK_R:
    //             for(boolean[] i : edgeData) for(let j = 0; j < i.length; j++) i[j] = false;
    //             for(let[] i : triangleData) for(let j = 0; j < i.length; j++) i[j] = 0;
    //             break;
    //         case KeyEvent.VK_V:
    //             showGrid = !showGrid; break;
    //         default:break;
    //     }
    // }
    // @Override
    // public void onKeyReleased(let keyCode){}
    // @Override
    // public void onKeyTyped(let keyCode){}
    // //Called every time the display needs to update
    // public paint():void{
    //     //Recalculate dimensions
    //     const WIDTH = this.canvas.width, HEIGHT = this.canvas.height;
    //     //Paint board background
    //     this.canvas.clear("#EEE");
    //     //this.canvas.setFillColor("rgb(200,200,200)");
    //     //this.canvas.fillRect(LEFT_OFFSET, TOP_OFFSET, LEFT_OFFSET + this.SIZE, TOP_OFFSET + this.SIZE);
    //     // this.canvas.setDrawColor("#000");
    //     // //Draw grid
    //     // for(let i = 0; i <= BOARD_SIZE; i++){
    //     //     const offset =  i * this.SIZE / BOARD_SIZE;
    //     //     this.canvas.line(LEFT_OFFSET, TOP_OFFSET + offset, WIDTH - LEFT_OFFSET, TOP_OFFSET + offset);
    //     //     this.canvas.line(LEFT_OFFSET + offset, TOP_OFFSET, LEFT_OFFSET + offset, HEIGHT - TOP_OFFSET);
    //     // }
    //     // const PADDING = ~~(this.SIZE / BOARD_SIZE / 9);
    //     // //Draw pieces
    //     // for(let i = 0; i < GameLogic.BOARD_SIZE; i++){
    //     //     for(let j = 0; j < GameLogic.BOARD_SIZE; j++){
    //     //         const circleX = LEFT_OFFSET + i * this.SIZE / BOARD_SIZE;
    //     //         const circleY = TOP_OFFSET  + j * this.SIZE / BOARD_SIZE;
    //     //         switch(this.logic.getPieceAt(i, j)){
    //     //             case BOARD_CELL.PLAYER:
    //     //                 this.canvas.circle(circleX + PIECE_RAD, circleY + PIECE_RAD, PIECE_RAD - PADDING);
    //     //                 break;
    //     //             case BOARD_CELL.OPPONENT:
    //     //                 this.canvas.fillCircle(circleX + PIECE_RAD, circleY + PIECE_RAD, PIECE_RAD - PADDING);
    //     //                 break;
    //     //         }
    //     //     }
    //     // }
    // }
    onKeyPressed(keyCode) {
    }
    onMouseDown(x, y) {
    }
    onMouseUp(x, y) {
    }
    onMouseMove(x, y) {
    }
    onMouseWheel(d) {
        this.scale *= 1 - d * .0004;
    }
}

window.a = new GameDisplay();

})();